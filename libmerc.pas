unit libmerc;

interface

uses Windows, Messages, Classes, cPort, SysUtils;

type
  TocMercury = class(TComponent)
    private
      FcpCom1: TComPort;
      FiTimeOut: Integer;
      FPortName: string;
      FBaudRate: TBaudRate;
      FbInitOk: Bool;

      FsCommand: string;
      FbSubCommand: Byte;
      FsCheckSum: string;
      FscpFRPortData: string;

      DecimalSeparator: string;
      FsPassword: string;
      FiOperator: Word;
      FsOperatorName: string;
      FiTitleStringsCount: Word;
      FbCnFeedLines: Byte;

      FsPrintLine: string;
      FsPrintLine1: string;
      FcPrice: Currency;
      FcQty: Currency;
      FiDepartment: Byte;
      FcCash: Currency;

      FiLastECRSt: Integer;    //
      FiLastResult: Integer;   // These values are directly received from ECR Answer
      FiLastPrSt: Integer;     //

      FbDocIsActive: Bool;
      FsLastEcrSt: string;     // These values are generated by lmECRState &
      FsLastPrSt: string;      // lmPrintState functions respectively

      FiNDoc: Integer;

      procedure ComPortRxChar(Sender: TObject; Count: Integer);
      procedure DecodeFRAnswer(sFRAnswer: string);
    protected
      function GetBaudRate: Integer;
      procedure SetBaudRate(Value: Integer);
      function GetConnected: Bool;
      function GetStrLastResult: string;

      function GetFsOperatorName: string;
      procedure SetFsOperatorName(Value: string);
      function GetFsPrintLine: string;
      procedure SetFsPrintLine(Value: string);
    public
    {properties storage}
      property PortName: string read FPortName write FPortName;
      property BaudRate: Integer read GetBaudRate write SetBaudRate;
      property TimeOut: Integer read FiTimeOut write FiTimeOut;
      property Connected: Bool read GetConnected;

      property Password: string read FsPassword write FsPassword;
      property Operator: string read GetFsOperatorName write SetFsOperatorName;
      property OperNumber: Word read FiOperator write FiOperator;
      property StringForPrinting: string read GetFsPrintLine write SetFsPrintLine;
      property Price: Currency read FcPrice write FcPrice;
      property Quantity: Currency read FcQty write FcQty;
      property Summ1: Currency read FcCash write FcCash;                       // Cash Money
      property InitOk: Bool read FbInitOk;
      property ResultCode: Integer read FiLastResult;
      property ResultCodeDescription: string read GetStrLastResult;
      property EcrStateDescr: string read FsLastEcrSt;
      property PrinterStateDescr: string read FsLastPrSt;
      property SubCommand: Byte read FbSubCommand write FbSubCommand;
      property Department: Byte read FiDepartment write FiDepartment;
      property TitleStringsCount: Word read FiTitleStringsCount write FiTitleStringsCount;
      property DocIsActive: Bool read FbDocIsActive;
      property OpenDocumentNumber: Integer read FiNDoc;

      constructor Create(AOwner: TComponent); override;
      destructor Destroy; override;
      procedure Connect;
      procedure Disconnect;
      procedure AwaitingResult;
      procedure GetECRStatus;

      procedure PrintString(bWide: Bool);
      procedure Print2Strings;
      procedure PrintDocFreeStr(bWide: Bool);

      procedure OpenSession;
      procedure CancelCheck;
      procedure PrintDocumentTitle;
      procedure Sale;
      procedure ReturnSale;
      procedure CashIncome;
      procedure CashOutcome;
      procedure CloseCheck;
      procedure PrintReportWithCleaning;
      procedure PrintReportWithDeparts;
      procedure PrintReportWithoutCleaning;
      procedure FeedDocument;
      procedure Cut;
      procedure OpenDrawer;

      function lmECRState: Word;
      function lmStrResult: string;
      function lmPrintState: Word;
      function str2hex(sInLine: string): string;
      function CSCalc(param: string): string;
  end;

implementation

const STX: Char = #02;
      ETX: Char = #03;

var dwTimeOut: Integer;// DWord; // API TIMER
    iStrLen: Integer;
    oSelf: TocMercury;

procedure lpTimerProc(hwnd: HWnd; umsg: UInt; idEvent: UInt; dwTime: DWord); stdcall; export;
begin
  KillTimer(0, idEvent);
  dwTimeOut := 0;
  if Assigned(oSelf) then
     with oSelf do begin
        if (Length(FscpFRPortData) <> 0) and (FscpFRPortData[1] = STX) and
           (Pos(ETX, FscpFRPortData) = 0) then begin
           DecodeFRAnswer(FscpFRPortData);
           FiLastResult := $F003;
        end else
           FiLastResult := $F001; // Timeout Expired
     end;
//  messagebox(0, 'Превышено время ожидания отклика. Возможно фискальный регистратор выключен,'#13#10 +
//                'нарушен интерфейс или вызвана команда в момент выполнения предыдущей.', '', $30);
end;

constructor TocMercury.Create(AOwner: TComponent);
var iPortNum: Byte;
begin
  inherited Create(AOwner);
  oSelf := Self;      // Store object to global var
  FbInitOk := False;
  FiTimeOut := 2000;
  FsPassword := '0000';
  FsOperatorName := 'Кассир1';
  FiOperator := 01;
  FiTitleStringsCount := 04;
  FbCnFeedLines := 02;
  FcpCom1 := TComPort.Create(Self);
end;

destructor TocMercury.Destroy;
begin
  if FcpCom1.Connected then
     FcpCom1.Close;
  FcpCom1.Free;
  inherited Destroy;
end;

procedure TocMercury.Connect;

  procedure SetComFlowControl;
  begin
    //FcpCom1.TriggersOnRxChar := False;
    //FcpCom1.
    with FcpCom1 do begin
             //  evRxChar, evTxEmpty, evRxFlag, evRing, evBreak, evCTS, evDSR, evError, evRLSD, evRx80Full
      Events := [evRxChar, evError]; //, evTxEmpty
      //SyncMethod := smWindowSync;
      //SyncMethod := smNone;
      FlowControl.ControlDTR := dtrDisable;
      FlowControl.ControlRTS := rtsDisable;
      FlowControl.OutCTSFlow := False;
      FlowControl.OutDSRFlow := False;
      FlowControl.XonXoffOut := False;
      FlowControl.XonXoffIn := False;
      OnRxChar := ComPortRxChar;
    end;
  end;

begin
  FcpCom1.Port := FPortName;
  FcpCom1.BaudRate := FBaudRate;

  if FcpCom1.Connected then
     FcpCom1.Close;

  SetComFlowControl;
  FcpCom1.Open;
end;

procedure TocMercury.Disconnect;
begin
  FcpCom1.Close;
end;

procedure TocMercury.ComPortRxChar(Sender: TObject; Count: Integer);
var n: Integer;
    BOPkt, EOPkt: Word;
    sFRAnswer,
    sData,
    sUDFMesg: string;
begin
  if Count = 0 then
    Exit;

  EOPkt := 0; BOPkt := 0; sFRAnswer := '';

  FcpCom1.ReadStr(sData, Count);

  case sData[1] of
    #06: begin                                                                 // FR Busy

           if dwTimeOut <> 0 then begin
             KillTimer(0, dwTimeOut);
             dwTimeOut:= SetTimer(0, 0, FiTimeOut, @lpTimerProc);
           end;

           while (length(sData) <> 0) and (sData[1] = #06) do
             Delete(sData, 1, 1);

         end;

    #05: begin                                                             // printer error

           KillTimer(0, dwTimeOut);
           dwTimeOut := 0;

           FiLastPrSt := $FF;
           if length(sData) > 3 then
              try
                FiLastPrSt := StrToInt('0x' + sData[2] + sData[3]);
              except
              end;

           if lmPrintState > 0 then
              sUDFMesg := '0x' + sData[2] + sData[3] + ': ' + FsLastPrSt;

           if MessageBox(0, PChar(sUDFMesg), 'Ответ ФР', $35) = 4 then begin
              dwTimeOut:= SetTimer(0, 0, FiTimeOut, @lpTimerProc);
              FcpCom1.WriteStr(#04);                                           // retry print
           end else begin
              FcpCom1.WriteStr(#01);                                           // cancel
              FiLastResult := $F002;
           end;

           FscpFRPortData := '';

         end;
  end;

  FscpFRPortData := FscpFRPortData + sData;

  BOPkt := Pos(STX, FscpFRPortData);
  EOPkt := Pos(ETX, FscpFRPortData);

  if (BOPkt > 0) and (EOPkt > 0) then begin                                    // Full packet received

     KillTimer(0, dwTimeOut);
     dwTimeOut := 0;

     sFRAnswer := Copy(FscpFRPortData, BOPkt, EOPkt);

     DecodeFRAnswer(sFRAnswer);

     FscpFRPortData := '';

  end;

  if BOPkt = 0 then                                                            // если нет стартового байта - значит имеем мусор.
     FscpFRPortData := '';

end;

procedure TocMercury.AwaitingResult;
var lpMsg1, lpMsg2: TMsg;
    iC: Integer;
begin

  FillChar(lpMsg2, SizeOf(lpMsg2), 0);
  FiLastResult := -1;
  dwTimeOut := SetTimer(0, 0, FiTimeOut, @lpTimerProc);

  if Length(FsCommand) > 0 then
     FcpCom1.WriteStr(FsCommand);                                              // For ALL commands except PrinterError

  repeat
    GetMessage(lpMsg1, 0, 0, 0);
    if (lpMsg1.message = WM_KEYDOWN) and (lpMsg1.wParam = VK_RETURN) then begin
       lpMsg2 := lpMsg1;
       lpMsg1.wParam := 0;                                                     // Lock new commands with Return Key
    end;
    TranslateMessage(lpMsg1);
    DispatchMessage(lpMsg1);
  until (FiLastResult <> -1);

  if lpMsg2.wParam = VK_RETURN then begin // if occurs VK_Return once,
     TranslateMessage(lpMsg2);
     DispatchMessage(lpMsg2);
  end;
end;

procedure TocMercury.DecodeFRAnswer(sFRAnswer: string);                        // sFRAnswer = between STX & ETX
var iMsgCode: Byte;
    iFrCNullPos, iCurrDate: Integer;
    cRemain: Currency;
begin

  if Length(sFRAnswer) > 7 then begin                                          // ECRState
     try
       FiLastECRSt := StrToInt('0x' + Copy(sFRAnswer, 4, 4));
     except
       FiLastECRSt := $FFFF;
     end;
     lmEcrState;
  end else
     FiLastECRSt := $FFFF;

  if Length(sFRAnswer) > 11 then                                               // Cmd Result
     try
       FiLastResult := StrToInt('0x' + Copy(sFRAnswer, 9, 4));
     except
       FiLastResult := $F004;
     end
  else
     FiLastResult := $F004;

  if Length(sFRAnswer) > 15 then                                               // Printer State
     try
       FiLastPrSt := StrToInt('0x' + Copy(sFRAnswer, 14, 2));
     except
       FiLastPrSt := $FF;
     end
  else
     FiLastPrSt := $FF;

//  if (FRString[2] = #$31) and (FiLastResult = 0) then begin                  // ndoc received

  if (sFRAnswer[2] = #$4A) and (FiLastResult = 0) then begin                   // ndoc received
     iFrCNullPos := Pos(#0, Copy(sFRAnswer, 20, 6));
     try
       FiNDoc := StrToInt(Copy(sFRAnswer, 20, iFrCNullPos));
     except
       FiNDoc := -1;
     end;
  end;

  PostThreadMessage(GetCurrentThreadId, WM_USER, 0, 0);                        // для AwaitingResult

end;

{******************************************************************************}
{* ECR commands                                                               *}
{******************************************************************************}

procedure TocMercury.GetECRStatus;                                              // Запрос номера документа
begin

  FsCommand := #$4A + FsPassword + #$00;
  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

end;

procedure TocMercury.OpenSession;
begin

  iStrLen := Length(FsOperatorName);
  iStrLen := 40 - iStrLen;

  FsCommand := #$31 + FsPassword + #0 + FormatFloat('00', FiOperator) + #0 + FsOperatorName + #0;
  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

end;

procedure TocMercury.CancelCheck;
begin

  GetECRStatus;

  if FbDocIsActive then begin

     FsCommand := '000' + #0;                                                     // 9-10 Accessories count (dummy)
     FsCommand := '08'#0 + FsCommand;                                             // 7-8 Document flags '00'..'FF'
     FsCommand := FormatFloat('0', FbSubCommand) + #0 + FsCommand;                // 5-6 '0'..'3', 43h
     FsCommand := #$53 + FsPassword + #0 + FsCommand;                             // 2-3-4 CMD

     FsCheckSum := Copy(CSCalc(FsCommand), 3, 2);
     FsCommand := STX + FsCommand + FsCheckSum + ETX;

     AwaitingResult;

  end;
end;

procedure TocMercury.PrintDocumentTitle;
var iCounter, iStrLen: Integer;
begin

  FsCommand := '';

  for iCounter := 0 to FiTitleStringsCount - 1 do
    FsCommand := FsCommand +
                 FormatFloat('00', iCounter + 1) +                             // ac type
                 #0'1000'#0'00'#0 +                                            // ac flags :: x offset
                 FormatFloat('000', iCounter) +                                // y offset
                 #0#0#0#0#0#0 +                                                // obsolete
                 StringOfChar(#$20, 40) + #0; // Title String

  iCounter := FiTitleStringsCount;

  FsCommand := FsCommand + '10'#0'1000'#0'00'#0 + FormatFloat('000', iCounter) + #0#0#0#0#0#0 + StringOfChar(#$20, 40) + #0;
  FsCommand := FsCommand + '05'#0'1000'#0'24'#0 + FormatFloat('000', iCounter) + #0#0#0#0#0#0 + StringOfChar(#$20, 40) + #0;

  Inc(iCounter);
  FsCommand := FsCommand + '00'#0'1000'#0'00'#0 + FormatFloat('000', iCounter) + #0#0#0#0#0#0 + StringOfChar(#$20, 40) + #0;
  FsCommand := FsCommand + '07'#0'1000'#0'11'#0 + FormatFloat('000', iCounter) + #0#0#0#0#0#0 + StringOfChar(#$20, 40) + #0;
  FsCommand := FsCommand + '08'#0'1000'#0'20'#0 + FormatFloat('000', iCounter) + #0#0#0#0#0#0 + StringOfChar(#$20, 40) + #0;
  Inc(iCounter);
  FsCommand := FsCommand + '06'#0'1000'#0'00'#0 + FormatFloat('000', iCounter) + #0#0#0#0#0#0 + StringOfChar(#$20, 40) + #0;
  Inc(iCounter);
  iStrLen := Length(FsPrintLine);
  iStrLen := 40 - iStrLen;
  FsCommand := FsCommand + '99'#0'1000'#0'00'#0 + FormatFloat('000', iCounter) + #0#0#0#0#0#0 + FsPrintLine + StringOfChar(#$20, iStrLen) + #0;
// ^

  FsCommand := FormatFloat('000', FiTitleStringsCount + 7) + #0 + FsCommand;   // 9-10 Accessories count
  FsCommand := '00'#0 + FsCommand;                                             // 7-8 Document flags '00'..'FF'
  FsCommand := FormatFloat('0', FbSubCommand) + #0 + FsCommand;                // 5-6 '0'..'3', 43h
  FsCommand := #$53 + FsPassword + #0 + FsCommand;                             // 2-3-4 CMD

  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

  sleep(100); // ККМ не успевает отработать команду если немедленно закрывать чек...
end;

procedure TocMercury.Sale;
var sTmp: string;
begin
  DecimalSeparator:=#$2E;
  FbSubCommand := 0;                                                           // Sale subcommand
  FsCommand := '';

  iStrLen := Length(FsPrintLine);
  iStrLen := 40 - iStrLen;
  FsCommand := FsCommand + '99'#0'1000'#0'00'#0'000'#0#0#0#0#0#0 + FsPrintLine + StringOfChar(#$20, iStrLen) + #0;
  FsCommand := FsCommand + '11'#0'1002'#0'0'#0#0'1'#0#0#0 + FormatFloat('0', Department) + #0#0'0'#0#0#0#0#0#0#0#0#0#0#0#0;     // 1-8
//  FsCommand := FsCommand + '11'#0'1002'#0'0'#0#0'1'#0#0#0'1'#0#0'0'#0#0#0#0#0#0#0#0#0#0#0#0;     // 1-8
  sTmp      := FormatFloat('#0.###', Abs(FcQty));
  FsCommand := FsCommand + sTmp + StringOfChar(#0, 11 - Length(sTmp)) + #0;    // кол-во
  sTmp      := FormatFloat('##0.00', FcPrice);
  FsCommand := FsCommand + sTmp + StringOfChar(#0, 11 - Length(sTmp)) + #0;    // цена услуги
  FsCommand := FsCommand + StringOfChar(#$20, 5) + #0;                         // ед. изм.

  FsCommand := '002'#0 + FsCommand;                                            // 9-10 Accessories count
  FsCommand := '00'#0 + FsCommand;                                             // 7-8 Document flags '00'..'FF'
  FsCommand := FormatFloat('0', FbSubCommand) + #0 + FsCommand;                // 5-6 '0'..'3', 43h
  FsCommand := #$53 + FsPassword + #0 + FsCommand;                             // 2-3-4 CMD

  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;
end;

procedure TocMercury.ReturnSale;
var sTmp: string;
begin
  DecimalSeparator:=#$2E;
  FbSubCommand := 1;                                                           // Sale subcommand
  FsCommand := '';

  iStrLen := Length(FsPrintLine);
  iStrLen := 40 - iStrLen;
  FsCommand := FsCommand + '99'#0'1000'#0'00'#0'000'#0#0#0#0#0#0 + FsPrintLine + StringOfChar(#$20, iStrLen) + #0;
  FsCommand := FsCommand + '11'#0'1002'#0'0'#0#0'1'#0#0#0'1'#0#0'0'#0#0#0#0#0#0#0#0#0#0#0#0;     // 1-8
  sTmp      := FormatFloat('#0.###', Abs(FcQty));
  FsCommand := FsCommand + sTmp + StringOfChar(#0, 11 - Length(sTmp)) + #0;    // кол-во
  sTmp      := FormatFloat('##0.00', FcPrice);
  FsCommand := FsCommand + sTmp + StringOfChar(#0, 11 - Length(sTmp)) + #0;    // цена услуги
  FsCommand := FsCommand + StringOfChar(#$20, 5) + #0;                         // ед. изм.

  FsCommand := '002'#0 + FsCommand;                                            // 9-10 Accessories count
  FsCommand := '00'#0 + FsCommand;                                             // 7-8 Document flags '00'..'FF'
  FsCommand := FormatFloat('0', FbSubCommand) + #0 + FsCommand;                // 5-6 '0'..'3', 43h
  FsCommand := #$53 + FsPassword + #0 + FsCommand;                             // 2-3-4 CMD

  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;
end;

procedure TocMercury.CashIncome;
var sTmp: string;
begin
  DecimalSeparator:=#$2E;
  FbSubCommand := 2;                                                           // Cash Income
  FsCommand := '';

  iStrLen := Length(FsPrintLine);
  iStrLen := 40 - iStrLen;
  FsCommand := FsCommand + '99'#0'1000'#0'00'#0'000'#0#0#0#0#0#0 + FsPrintLine + StringOfChar(#$20, iStrLen) + #0;
  FsCommand := FsCommand + '11'#0'1002'#0'0'#0#0'1'#0#0#0'1'#0#0'0'#0#0#0#0#0#0#0#0#0#0#0#0;     // 1-8
  sTmp      := FormatFloat('#0.###', Abs(FcQty));
  FsCommand := FsCommand + sTmp + StringOfChar(#0, 11 - Length(sTmp)) + #0;    // кол-во
  sTmp      := FormatFloat('##0.00', FcPrice);
  FsCommand := FsCommand + sTmp + StringOfChar(#0, 11 - Length(sTmp)) + #0;    // цена услуги
  FsCommand := FsCommand + StringOfChar(#$20, 5) + #0;                         // ед. изм.

  FsCommand := '002'#0 + FsCommand;                                            // 9-10 Accessories count
  FsCommand := '00'#0 + FsCommand;                                             // 7-8 Document flags '00'..'FF'
  FsCommand := FormatFloat('0', FbSubCommand) + #0 + FsCommand;                // 5-6 '0'..'3', 43h
  FsCommand := #$53 + FsPassword + #0 + FsCommand;                             // 2-3-4 CMD

  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;
end;

procedure TocMercury.CashOutcome;
var sTmp: string;
begin
  DecimalSeparator:=#$2E;
  FbSubCommand := 3;                                                           // Cash Outcome
  FsCommand := '';

  iStrLen := Length(FsPrintLine);
  iStrLen := 40 - iStrLen;
  FsCommand := FsCommand + '99'#0'1000'#0'00'#0'000'#0#0#0#0#0#0 + FsPrintLine + StringOfChar(#$20, iStrLen) + #0;
  FsCommand := FsCommand + '11'#0'1002'#0'0'#0#0'1'#0#0#0'1'#0#0'0'#0#0#0#0#0#0#0#0#0#0#0#0;     // 1-8
  sTmp      := FormatFloat('#0.###', Abs(FcQty));
  FsCommand := FsCommand + sTmp + StringOfChar(#0, 11 - Length(sTmp)) + #0;    // кол-во
  sTmp      := FormatFloat('##0.00', FcPrice);
  FsCommand := FsCommand + sTmp + StringOfChar(#0, 11 - Length(sTmp)) + #0;    // цена услуги
  FsCommand := FsCommand + StringOfChar(#$20, 5) + #0;                         // ед. изм.

  FsCommand := '002'#0 + FsCommand;                                            // 9-10 Accessories count
  FsCommand := '00'#0 + FsCommand;                                             // 7-8 Document flags '00'..'FF'
  FsCommand := FormatFloat('0', FbSubCommand) + #0 + FsCommand;                // 5-6 '0'..'3', 43h
  FsCommand := #$53 + FsPassword + #0 + FsCommand;                             // 2-3-4 CMD

  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;
end;

procedure TocMercury.CloseCheck;
var sTmp: string;
begin
  FsCommand := '';

  FsCommand := FsCommand + '12'#0'1000'#0'00'#0'000'#0#0#0#0#0#0 + StringOfChar(#0, 40) + #0;

  if FbSubCommand = 0 then begin                                               // 9-10 Accessories count
     sTmp      := FormatFloat('##0.00', FcCash);
     FsCommand := FsCommand + '13'#0'1000'#0'00'#0'001'#0#0#0#0#0#0 + sTmp + StringOfChar(#0, 40 - Length(sTmp)) + #0;
     FsCommand := FsCommand + '14'#0'1000'#0'00'#0'002'#0#0#0#0#0#0 + StringOfChar(#0, 40) + #0;
// ***************
     iStrLen := Length(FsPrintLine);
     iStrLen := 40 - iStrLen;
     FsCommand := FsCommand + '99'#0'1000'#0'00'#0'003'#0#0#0#0#0#0 + FsPrintLine + StringOfChar(#$20, iStrLen) + #0;
// ***************
     FsCommand := '004'#0 + FsCommand;
  end else
     FsCommand := '001'#0 + FsCommand;

  FsCommand := '04'#0 + FsCommand;                                             // 7-8 Document flags '00'..'FF'
  FsCommand := FormatFloat('0', FbSubCommand) + #0 + FsCommand;                // 5-6 '0'..'3', 43h
  FsCommand := #$53 + FsPassword + #0 + FsCommand;                             // 2-3-4 CMD

  FsCheckSum := Copy(CSCalc(FsCommand), 3, 2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

end;

//////////////////////////////////////////////////////////////////////

procedure TocMercury.PrintString(bWide: Bool);
begin

  FsCommand := '';

  iStrLen := Length(FsPrintLine);
  iStrLen := 40 - iStrLen;
  FsCommand := FsCommand + '99'#0;
  if bWide then
     FsCommand := FsCommand + '0000'
  else
     FsCommand := FsCommand + '1000';
  FsCommand := FsCommand + #0'00'#0'000'#0#0#0#0#0#0 + FsPrintLine + StringOfChar(#$20, iStrLen) + #0;

  FsCommand := '001'#0 + FsCommand;                                            // 9-10 Accessories count
  FsCommand := '00'#0 + FsCommand;                                             // 7-8 Document flags '00'..'FF'
  FsCommand := FormatFloat('0', FbSubCommand) + #0 + FsCommand;                // 5-6 '0'..'3', 43h
  FsCommand := #$53 + FsPassword + #0 + FsCommand;                             // 2-3-4 CMD

  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

end;

procedure TocMercury.PrintDocFreeStr(bWide: Bool);
begin
  FsCommand := #$36 + FsPassword + #0;                                         // 2-3-4
  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

  FsCommand := '';

  if bWide then
     FcpCom1.WriteStr(#$1B#$21#1);

  FcpCom1.WriteStr(FsPrintLine);
  FcpCom1.WriteStr(#$D#$A#$FF);
  FcpCom1.WriteStr(#$1B#$1B);

  AwaitingResult;
end;

procedure TocMercury.Print2Strings;
begin
  FsCommand := '';

  iStrLen := Length(FsPrintLine);
  iStrLen := 40 - iStrLen;
  FsCommand := FsCommand + '99'#0'1000'#0'00'#0'001'#0#0#0#0#0#0 + FsPrintLine + StringOfChar(#$20, iStrLen) + #0;
  iStrLen := Length(FsPrintLine1);
  iStrLen := 40 - iStrLen;
  FsCommand := FsCommand + '99'#0'1000'#0'00'#0'002'#0#0#0#0#0#0 + FsPrintLine1 + StringOfChar(#$20, iStrLen) + #0;

  FsCommand := '002'#0 + FsCommand;                                            // 9-10 Accessories count
  FsCommand := '00'#0 + FsCommand;                                             // 7-8 Document flags '00'..'FF'
  FsCommand := FormatFloat('0', FbSubCommand) + #0 + FsCommand;                // 5-6 '0'..'3', 43h
  FsCommand := #$53 + FsPassword + #0 + FsCommand;                             // 2-3-4 CMD

  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

end;

{******************************************************************************}
{* Std Daily Reports                                                          *}
{******************************************************************************}

procedure TocMercury.PrintReportWithCleaning;
begin

  DecimalSeparator := #$2E;

  FsCommand := #$5F + FsPassword + #0#$30#0;
  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

end;

procedure TocMercury.PrintReportWithDeparts;
begin

  DecimalSeparator := #$2E;

  FsCommand := #$5F + FsPassword + #0#$33#0;
  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

end;

procedure TocMercury.PrintReportWithoutCleaning;
begin

  DecimalSeparator := #$2E;

  FsCommand := #$5F + FsPassword + #0#$31#0;
  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

end;

{******************************************************************************}
{* non-fiscal operations                                                      *}
{******************************************************************************}

procedure TocMercury.FeedDocument;
var iC: Byte;
begin

  FsCommand := #$36 + FsPassword + #0;                                      // 2-3-4
  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

  for iC := 0 to FbCnFeedLines - 1 do
     FcpCom1.WriteStr(#$A#$D);

  FcpCom1.WriteStr(#$1B#$1B);

  AwaitingResult;

end;

procedure TocMercury.Cut;
var iC: Byte;
begin

  FsCommand := #$36 + FsPassword + #0;                                      // 2-3-4
  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

  for iC := 0 to FbCnFeedLines - 1 do
     FcpCom1.WriteStr(#$1B#$64#$30);

  FcpCom1.WriteStr(#$1B#$1B);

  AwaitingResult;

end;

procedure TocMercury.OpenDrawer;
begin

  FsCommand := #$38 + FsPassword + #0#$30#0'05'#0'02'#0'02'#0;
  FsCheckSum := Copy(CSCalc(FsCommand),3,2);
  FsCommand := STX + FsCommand + FsCheckSum + ETX;

  AwaitingResult;

end;

{******************************************************************************}
{* Data Functions Section                                                     *}
{******************************************************************************}

function TocMercury.lmStrResult: string;
begin
  case FiLastResult of
    $0000: Result := 'Команда выполнена успешно';
    $0001: Result := 'Ошибка в фискальных данных, аппарат блокирован.';
    $0002: Result := 'Не закрыта смена.';
    $0003: Result := 'Исчерпан ресурс сменных записей в фискальную память.';
    $0004: Result := 'Превышена длина поля команды.';
    $0005: Result := 'Неверный формат поля команды.';
    $0006: Result := 'Ошибка чтения таймера.';
    $0007: Result := 'Неверная дата.';
    $0008: Result := 'Неверное время.';
    $0009: Result := 'Дата меньше последней даты, зарегистрированной в фискальной памяти.';
    $000A: Result := 'Операция прервана пользователем.';
    $000B: Result := 'Запрещенная команда ПУ';
    $000C: Result := 'Не открыта смена.';
    $000D: Result := 'Кассир не зарегистрирован.';
    $000E: Result := 'Переполнение приёмного буфера.';
    $000F: Result := 'Ошибка записи в фискальную память.';
    $0010: Result := 'Ошибка установки таймера.';
    $0011: Result := 'Неверный пароль налогового инспектора.';
    $0012: Result := 'Неверный пароль на связь.';
    $0013: Result := 'Исчерпан ресурс перерегистраций.';
    $0014: Result := 'Аппарат не фискализирован.';
    $0015: Result := 'Значение поля команды вне диапазона.';
    $0016: Result := 'Ошибка чтения фискальной памяти.';
    $0017: Result := 'Переполнение или отрицательный результат счётчика.';
    $0018: Result := 'Обязательное поле команды имеет нулевую длину.';
    $0019: Result := 'Неверный формат команды.';
    $001A: Result := 'Дата или время последнего документа в смене меньше предыдущего.';
    $001B: Result := 'Не используется.';
    $001C: Result := 'Ошибка в расположении реквизитов (пересечение или выход за область печати).';
    $001D: Result := 'Нет такой команды.';
    $001E: Result := 'Неверная контрольная сумма (BCC)';
    $001F: Result := 'Нет фискальных записей.';
    $0021: Result := 'Оформление документа прервано по окончанию времени ожидания готовности принтера.';
    $0024: Result := 'Буфер ответа пуст.';
    $0025: Result := 'Услуга не введена';
    $0029: Result := 'Дублирование обязательных реквизитов документа.';
    $002A: Result := 'Текущее состояние ККМ не позволяет выполнить операцию.';
    $002B: Result := 'Ошибка в данных энергонезависимой памяти. Аппарат блокирован.';
    $002C: Result := 'Невозможно выполнить инициализацию ФП. ФП уже инициализирована.';
    $002D: Result := 'Вывод прерван по окончанию времени ожидания готовности дисплея.';
    $002E: Result := 'Ошибка записи FLASH памяти.';
    $002F: Result := 'Ошибка. Нет записей.';
    $0030: Result := 'Ошибка связи с ЭКЛЗ';
    $0031: Result := 'Некорректный формат или параметр команды ЭКЛЗ';
    $0032: Result := 'Некорректное состояние ЭКЛЗ';
    $0033: Result := 'Авария ЭКЛЗ';
    $0034: Result := 'Авария криптографического процессора ЭКЛЗ';
    $0035: Result := 'Исчерпан временной ресурс использования ЭКЛЗ';
    $0036: Result := 'ЭКЛЗ переполнена';
    $0037: Result := 'Неверные дата или время в ЭКЛЗ';
    $0038: Result := 'Нет запрошенных данных в ЭКЛЗ';
    $0039: Result := 'Переполнение счётчиков ЭКЛЗ';
    $0042: Result := 'Сбой криптопроцессора ЭКЛЗ';
    $0046: Result := 'Ошибка протокола обмена ЭКЛЗ';
    $0047: Result := 'Переполнение приёмного буфера ЭКЛЗ';
    $0048: Result := 'Неверная контрольная сумма ЭКЛЗ';
    $0049: Result := 'ЭКЛЗ активизирована в составе другой ККМ. Аппарат блокирован.';
    $004A: Result := 'ЭКЛЗ не активизирована.';
    $004B: Result := 'Неисправимая ошибка ЭКЛЗ';
    $004C: Result := 'Исчерпан ресурс активизаций ЭКЛЗ.';
    $004D: Result := 'ЭКЛЗ уже активизирована.';
    $004E: Result := 'Превышено количество секций в документе. (16 секций - ограничение ЭКЛЗ)';
    $004F: Result := 'Архив ЭКЛЗ закрыт или переполнение архива';
    $0050: Result := 'Ошибка. Данные фискальной памяти и ЭКЛЗ различаются.';
    $0070: Result := 'Переполнение счётчика количества в чеке, при сложении.';
    $0071: Result := 'Переполнение счётчика количества в чеке, при вычитании.';
    $0072: Result := 'Переполнение счётчика суммы аннулирований в чеке.';
    $0073: Result := 'Переполнение сменного счётчика суммы аннулирований.';
    $0074: Result := 'Переполнение сменного счётчика суммы продаж.';
    $0075: Result := 'Переполнение сменного счётчика суммы наличных.';
    $0076: Result := 'Переполнение сменного счётчика суммы оплаты в кредит.';
    $0077: Result := 'Переполнение сменного счётчика суммы оплаты картой.';
    $0078: Result := 'Переполнение сменного счётчика суммы наличных при вычитании.';
    $0079: Result := 'Переполнение сменного счётчика суммы возвратов при оплате в кредит.';
    $007a: Result := 'Переполнение счётчика итоговой суммы в чеке при добавлении.';
    $007b: Result := 'Переполнение счётчика итоговой суммы в чеке при вычитании.';
    $007c: Result := 'Переполнение счётчика стоимости в чеке, при умножении количества на стоимость.';
    $007d: Result := 'Переполнение счётчика итоговой суммы в чеке при вычислении скидки.';
    $007e: Result := 'Переполнение счётчика итоговой суммы по секции в чеке при вычислении скидки.';
    $007f: Result := 'Переполнение счётчика итоговой суммы учёта тары в чеке при вычислении скидки.';
    $0080: Result := 'Переполнение счётчика скидок в чеке.';
    $0081: Result := 'Переполнение счётчика итоговой суммы налоговой группы в чеке при вычислении скидки.';
    $0082: Result := 'Переполнение счётчика итоговой суммы безналоговой группы в чеке при вычислении скидки.';
    $0083: Result := 'Переполнение счётчика итоговой суммы в чеке при вычислении надбавки.';
    $0084: Result := 'Переполнение счётчика итоговой суммы по секции в чеке при вычислении надбавки.';
    $0085: Result := 'Переполнение счётчика итоговой суммы учёта тары в чеке при вычислении надбавки.';
    $0086: Result := 'Переполнение счётчика надбавок в чеке.';
    $0087: Result := 'Переполнение счётчика итоговой суммы налоговой группы в чеке при вычислении надбавки.';
    $0088: Result := 'Переполнение счётчика итоговой суммы безналоговой группы в чеке при вычислении надбавки.';
    $0089: Result := 'Переполнение счётчика итоговой суммы по секции в чеке.';
    $008a: Result := 'Переполнение счётчика итоговой суммы учёта тары в чеке.';
    $008b: Result := 'Переполнение счётчика итоговой суммы налоговой группы в чеке.';
    $008c: Result := 'Переполнение счётчика итоговой суммы безналоговой группы в чеке.';
    $008d: Result := 'Переполнение счётчика итоговой суммы в чеке при вычислении аннулирования скидки.';
    $008e: Result := 'Переполнение счётчика итоговой суммы по секции в чеке при вычислении аннулирования скидки.';
    $008f: Result := 'Переполнение счётчика итоговой суммы учёта тары в чеке при вычислении аннулирования скидки.';
    $0090: Result := 'Переполнение счётчика скидок в чеке при вычислении аннулирования скидки.';
    $0091: Result := 'Переполнение счётчика итоговой суммы налоговой группы в чеке при вычислении аннулирования скидки.';
    $0092: Result := 'Переполнение счётчика итоговой суммы безналоговой группы в чеке при вычислении аннулирования скидки.';
    $0093: Result := 'Переполнение счётчика итоговой суммы в чеке при вычислении аннулирования надбавки.';
    $0094: Result := 'Переполнение счётчика итоговой суммы по секции в чеке при вычислении аннулирования надбавки.';
    $0095: Result := 'Переполнение счётчика итоговой суммы учёта тары в чеке при вычислении аннулирования надбавки.';
    $0096: Result := 'Переполнение счётчика надбавок в чеке при вычислении аннулирования надбавки.';
    $0097: Result := 'Переполнение счётчика итоговой суммы налоговой группы в чеке при вычислении аннулирования надбавки.';
    $0098: Result := 'Переполнение счётчика итоговой суммы безналоговой группы в чеке при вычислении аннулирования надбавки.';
    $0099: Result := 'Сумма оплаты меньше суммы чека.';
    $009a: Result := 'Переполнение счётчика итоговой суммы оплаты при комбинированной оплате.';
    $009b: Result := 'Сумма безналичной оплаты больше суммы чека.';
    $009c: Result := 'Блокировка выполнения команды. Расхождение текущей даты и'#$20 +
                     'даты последней записи в ФП больше запрограммированного'#$20 +
                     'значения. Для снятия блокировки необходимо выполнить'#$20 +
                     'команду программирования даты.';
    $009d: Result := 'Блокировка выполнения команды. Последний документ не'#$20 +
                     'напечатан. После восстановления работоспособности принтера'#$20  +
                     '(зарядить бумагу, опустить печатающую головку, закрыть'#$20  +
                     'крышку) принтер автоматически распечатывает документ и'#$20  +
                     'снимает блокировку.';
    $009e: Result := 'Блокировка выполнения команды. Выполняется тестирование оборудования ККМ.';
    $F000: Result := 'Не удается открыть последовательный порт ФР';
    $F001: Result := 'Превышено время ожидания отклика от ФР. Вероятно, ФР выключен.';
    $F002: Result := 'Команда отменена пользователем вследствие ошибки печатающего устройства.';
    $F003: Result := 'Принят неполный пакет данных от ФР';
    $F004: Result := 'Не удается распознать ответ ФР';
    else
      Result := 'Не удается распознать ответ ФР';
  end;
end;

function TocMercury.lmPrintState: Word;
var iRes: Word;
begin
  if FiLastPrSt = $FF then begin
     FsLastPrSt := 'Неопознанная ошибка';
     lmPrintState := $FF;
     Exit;
  end;
  FsLastPrSt := '';
  iRes := 0;
  if (FiLastPrSt and $4) = 0 then begin
     FsLastPrSt := FsLastPrSt + 'Технологический режим'#$D#$A;
     iRes := iRes + $4;
  end;
  if (FiLastPrSt and $8) = 0 then begin
     FsLastPrSt := FsLastPrSt + 'Общая ошибка принтера.'#$D#$A;
     iRes := iRes + $8;
  end;
  if (FiLastPrSt and $20) > 0 then begin
     FsLastPrSt := FsLastPrSt + 'Конец бумаги.'#$D#$A;
     iRes := iRes + $20;
  end;
  if (FiLastPrSt and $40) = 0 then begin
     FsLastPrSt := FsLastPrSt + 'Принтер не готов.'#$D#$A;
     iRes := iRes + $40;
  end;
  if (FiLastPrSt and $80) > 0 then begin
     FsLastPrSt := FsLastPrSt + 'Принтер занят или Offline.'#$D#$A;
     iRes := iRes + $80;
  end;
  lmPrintState := iRes;
end;

function TocMercury.lmECRState: Word;
var iRes: Word;
begin
  if FiLastECRSt = $FFFF then begin
     FsLastEcrSt := 'Неопознанная ошибка';
     lmEcrState := $FF;
     Exit;
  end;
  FsLastEcrSt := '';
  iRes := 0;
  if (FiLastECRSt and $1) = 0 then
      FsLastEcrSt := FsLastEcrSt + 'Смена закрыта'#$D#$A
  else
      FsLastEcrSt := FsLastEcrSt + 'Смена открыта'#$D#$A;

  if (FiLastECRSt and $4) = 0 then
     FsLastEcrSt := FsLastEcrSt + 'Буфер копии документа в порядке'#$D#$A
  else
     FsLastEcrSt := FsLastEcrSt + 'Буфер копии документа близок к концу.'#$D#$A;

  if (FiLastECRSt and $20) = 0 then
     FsLastEcrSt := FsLastEcrSt + 'ФП в порядке'#$D#$A
  else
     FsLastEcrSt := FsLastEcrSt + 'Фискальная память близка к концу'#$D#$A;

  if (FiLastECRSt and $40) = 0 then
     FsLastEcrSt := FsLastEcrSt + 'ФП в порядке'#$D#$A
  else begin
     FsLastEcrSt := FsLastEcrSt + 'Фискальная память исчерпана'#$D#$A;
     iRes := iRes + $40;
  end;

  case (FiLastECRSt and $300) shr 8 of
     0: begin
          FsLastEcrSt := FsLastEcrSt + 'Документ закрыт'#$D#$A;
          FbDocIsActive := False;
        end;
     1: begin
          FsLastEcrSt := FsLastEcrSt + 'Документ открыт'#$D#$A;
          FbDocIsActive := True;
        end;
     2: begin
          FsLastEcrSt := FsLastEcrSt + 'Печать итога'#$D#$A;
          FbDocIsActive := True;
        end;
     3: begin
          FsLastEcrSt := FsLastEcrSt + 'Завершение документа'#$D#$A;
          FbDocIsActive := True;
        end;
  end;

  case (FiLastECRSt and $7C00) shr 10 of
     0: FsLastEcrSt := FsLastEcrSt + 'Продажа'#$D#$A;
     1: begin
          FsLastEcrSt := FsLastEcrSt + 'Возврат продажи'#$D#$A;
        end;
     2: begin
          FsLastEcrSt := FsLastEcrSt + 'Внесение суммы'#$D#$A;
        end;
     3: begin
          FsLastEcrSt := FsLastEcrSt + 'Выплата суммы'#$D#$A;
        end;
   $12: begin
          FsLastEcrSt := FsLastEcrSt + 'Возврат продажи б/н'#$D#$A;
        end;
   $1F: begin
          FsLastEcrSt := FsLastEcrSt + 'Документ закрыт'#$D#$A;
        end;
  end;
  lmECRState := iRes;
end;

function TocMercury.str2hex(sInLine: string): string;
var icounter:integer;
begin
  result := '';
  for iCounter:=1 to length(sInLine) do
    result := result + ' $' + inttohex(ord(sinline[icounter]),2);
end;

function TocMercury.CSCalc(param: string): string;
var Counter, CheckSum: Word;
begin
  CheckSum:=0;
  for Counter:=1 to Length(param) do begin
    CheckSum:=CheckSum+ord(param[Counter]);
  end;
  CSCalc:=IntToHex(CheckSum,4);
end;

{******************************************************************************}
{* Properties Section                                                         *}
{******************************************************************************}

procedure TocMercury.SetBaudRate(Value: Integer);
begin
  case Value of
     0: FBaudRate := br110;
     1: FBaudRate := br300;
     2: FBaudRate := br600;
     3: FBaudRate := br1200;
     4: FBaudRate := br2400;
     5: FBaudRate := br4800;
     6: FBaudRate := br9600;
     7: FBaudRate := br14400;
     8: FBaudRate := br19200;
     9: FBaudRate := br38400;
    10: FBaudRate := br56000;
    11: FBaudRate := br57600;
    12: FBaudRate := br115200;
  end;
end;

function TocMercury.GetBaudRate: Integer;
begin
  case FBaudRate of
   br110: GetBaudRate :=  0;
   br300: GetBaudRate :=  1;
   br600: GetBaudRate :=  2;
   br1200: GetBaudRate :=  3;
   br2400: GetBaudRate :=  4;
   br4800: GetBaudRate :=  5;
   br9600: GetBaudRate :=  6;
   br14400: GetBaudRate :=  7;
   br19200: GetBaudRate :=  8;
   br38400: GetBaudRate :=  9;
   br56000: GetBaudRate := 10;
   br57600: GetBaudRate := 11;
   br115200: GetBaudRate := 12;
  else
   GetBaudRate := -1;
  end;
end;

function TocMercury.GetConnected: Bool;
begin
  GetConnected := FcpCom1.Connected;
end;

function TocMercury.GetStrLastResult: string;
begin
  GetStrLastResult := lmStrResult;
end;

procedure TocMercury.SetFsOperatorName(Value: string);
var caTemp: array[0..40] of Char;
    sTemp: string;
begin
  sTemp := Copy(Value, 1, 40);
  //CharToOEM(PWideChar(sTemp), PAnsiChar(@caTemp));
  CharToOEM(PWideChar(sTemp), PAnsiChar(@caTemp));
  SetLength(FsOperatorName, Length(Value));
  FillChar(FsOperatorName, SizeOf(FsOperatorName), #$00);
  FsOperatorName := caTemp;
end;

function TocMercury.GetFsOperatorName: string;
var caTemp: array[0..40] of Char;
begin
  OEMToChar(PAnsiChar(FsOperatorName), PWideChaR(@caTemp));
  SetLength(Result, Length(FsOperatorName));
  Result := caTemp;
end;

procedure TocMercury.SetFsPrintLine(Value: string);
var caTemp: array[0..40] of Char;
    sTemp: string;
begin
  sTemp := Copy(Value, 1, 40);
  CharToOEM(PWideChar(sTemp), PAnsiChar(@caTemp));
  SetLength(FsPrintLine, Length(Value));
  FillChar(FsPrintLine, SizeOf(FsPrintLine), #$00);
  FsPrintLine := caTemp;
end;

function TocMercury.GetFsPrintLine: string;
var caTemp: array[0..40] of Char;
begin
  OEMToChar(PAnsiChar(FsPrintLine), PWideChar(@caTemp));
  SetLength(Result, Length(FsPrintLine));
  Result := caTemp;
end;

end.



{
function TocMercury.lmECRState(wState: Word; iCheckBit: Byte): Byte;
begin
  case iCheckBit of
    0: begin
         if (wState and $1) = 0 then
            FsLastEcrSt := 'Смена закрыта'
         else begin
            FsLastEcrSt := 'Смена открыта';
            Result := 1;
         end;
       end;
    1: begin
         if (wState and $2) = 0 then
            FsLastEcrSt := 'Ширина ленты 80мм'
         else begin
            FsLastEcrSt := 'Ширина ленты 57мм';
            Result := 1;
         end;
       end;
    2: begin
         if (wState and $4) = 0 then
            FsLastEcrSt := 'Буфер копии документа в порядке'
         else begin
            FsLastEcrSt := 'Буфер копии документа близок к концу.';
            Result := 1;
         end;
       end;
    3: begin
         FsLastEcrSt := 'Запрос не поддерживается';
         Result := 0;
       end;
    4: begin
         if (wState and $10) = 0 then
            FsLastEcrSt := ''
         else begin
            sTextState := 'Аппарат фискализирован';
            Result := 1;
         end;
       end;
    5: begin
         if (wState and $20) = 0 then
            sTextState := 'ФП в порядке'
         else begin
            sTextState := 'Фискальная память близка к концу';
            Result := 1;
         end;
       end;
    6: begin
         if (wState and $40) = 0 then
            sTextState := 'ФП в порядке'
         else begin
            sTextState := 'Фискальная память исчерпана';
            Result := 1;
         end;
       end;
    7: begin
         if (wState and $80) = 0 then
            sTextState := 'Протокол BS'
         else begin
            sTextState := 'Протокол XON/XOFF';
            Result := 1;
         end;
       end;
    8: begin
         case (wState and $300) shr 8 of
           0: sTextState := 'Документ закрыт';
           1: begin
                sTextState := 'Документ открыт';
                Result := 1;
              end;
           2: begin
                sTextState := 'Печать итога';
                Result := 2;
              end;
           3: begin
                sTextState := 'Завершение документа';
                Result := 3;
              end;
         end;
       end;
    9: begin
         sTextState := 'Запрос не поддерживается';
         Result := 0;
       end;
   10: begin
         case (wState and $7C00) shr 10 of
           0: sTextState := 'Продажа';
           1: begin
                sTextState := 'Возврат продажи';
                Result := 1;
              end;
           2: begin
                sTextState := 'Внесение суммы';
                Result := 2;
              end;
           3: begin
                sTextState := 'Выплата суммы';
                Result := 3;
              end;
         $12: begin
                sTextState := 'Возврат продажи б/н';
                Result := 4;
              end;
         $1F: begin
                sTextState := 'Документ закрыт';
                Result := 5;
              end;
         end;
       end;
   11..14: begin
         sTextState := 'Запрос не поддерживается';
         Result := 0;
       end;
   15: begin
         if (wState and $8000) = 0 then
            sTextState := 'Нет копии документа'
         else begin
            sTextState := 'Наличие копии последнего документа';
            Result := 1;
         end;
       end;
   end;
end;
}
